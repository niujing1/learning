### base dataType

**array**

```
var array [5]int 包含5个整型元素的数组
array := [5]int{1,2,3,4,5} 创建并初始化数组
array := [...]int{1,2,3,4} 数组长度为4
array := [5]int{1:2, 2:3} 初始化索引为1和2的元素，其它保持0值
```

**Usage:**

```
array := [5]int{1,2,3,4,5}
array[2] = 40 修改索引位2的元素值
array := [5]int{0:new(int), 1:new(int)} 声明包含5个指向整数的指针数组
*array[0] = 10
*array[1] = 20 为索引位0和1 的元素赋值

var array1 [5]string
array2 := [5]string{"a", "b", "c", "d", "e"}
array1 = array2  把变量2赋值给变量1
编译器会阻止不同类型的数据之间进行赋值(长度和每个元素的数据类型都必须相同)

复制指针时只会复制指针的值，而不会复制指针所指向的值
var array1 [3]string
array2 := [3]string{new(string), new(string), new(string)}
*array2[0] = "a"
*array2[1] = "b"
*array2[2] = "c" 为array的指针赋值

array1 = array2 将数组2赋值给数组1
```

#### 多维数组

```
var array [4][2]int

array := [3][2]int{{0,0}, {0,1}, {1,0}, {1,1}, {2,0}, {2,1}}
数组可以复制单个维度
var value int = array[1][0] 将单个数组元素赋值给变量
```

在函数间传递数组

```
在函数间传递数组会是一个很大的开销，因为在函数间传递变量时总是以值的方式进行传递，若值是一个数组，不管有多长都会完整的复制并传递给数组
假如声明了一个很大的数组，作为参数传入，那么每次函数调用时都必须在栈上分配对应的内存，此时我们可以只传递参数的地址(注意，此时若改变指针指向的值，会改变共享的内存)
使用切片会是更好的选择
```


